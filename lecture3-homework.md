# 第3课 课后作业

## 第1题

为了证明协议的完备性和可靠性，我们将分别检查两个方面。

(a) 完备性
假设 QR(m,x)=0 ，即 x 不是模 m 下的二次剩余。根据协议，Verifier 在与 m 互质的元素中均匀地随机选择一个 s∈Zm，并抛硬币 b←R{0,1}。然后，根据 b 的值计算 y，并将其发送给 Prover。

如果 Prover 遵循协议，则它会计算 QR(m,y) 并将结果发送回 Verifier。由于 QR(m,y) 的计算依赖于 y 的值，而 y 的值是根据 s 和 b 计算得到的，所以只有当 Prover 根据正确的 s 和 b 计算时，才能正确地计算出 QR(m,y) 的值。

在这种情况下，由于 x 不是模 m 下的二次剩余，且 Prover 按照协议行事，那么 Prover 将计算 QR(m,y) 的值为 0。因此，Verifier 收到的值与 b 相等，即接受该验证。

因此，协议满足完备性。

(b) 可靠性
假设 QR(m,x)=1 ，即 x 是模 m 下的二次剩余。无论 Prover 如何行动（不必遵循协议），Verifier 都以 ≥1/2 的概率拒绝。

根据协议，Verifier 随机选择一个 s∈Zm，并抛硬币 b←R{0,1}。然后计算 y 并将其发送给 Prover。

如果 Prover 不按照协议行事，它可以任意计算 QR(m,y) 的值，而不依赖于 y 的实际值。由于我们已经假设了二次剩余，即 x 是模 m 下的二次剩余，那么对于任何计算 QR(m,y) 的方法，Prover 得到 QR(m,y) = 1 的概率大于等于得到 QR(m,y) = 0 的概率。

因此，当 Prover 不遵循协议时，Verifier 拒绝的概率至少为 1/2。

因此，协议满足可靠性。

通过完备性和可靠性的证明，我们可以得出结论：如果 QR(m,x)=0 ，并且双方都按照协议行事，则验证者总是接受；如果 QR(m,x)=1 ，则无论 Prover 做什么（Prover 不必遵循协议），Verifier 都会以 ≥1/2 的概率拒绝。


## **第二题**

(a) 完备性：
假设双方都按照协议行事。根据协议，Prover 在与 m 互质的剩余中随机选择一个均匀的 t∈Zm，并将 y 发送给 Verifier。Verifier 抛硬币 b←R{0,1} 并将 b 发送给 Prover。Prover 根据 b 的值计算 u，并将其发送给 Verifier。Verifier 则根据 b 和 u 的值计算 y'。

如果 Prover 按照协议计算 u，那么根据协议定义，y'应该等于：

y'≡{u2xmodm if b=0,u2modm if b=1.

由于 Prover 按照协议行事，u 的计算方式取决于 b 的值，而 y 是基于 x、t 和 b 计算得到的。因此，当 b=0 时，Prover 计算 y' 应该是 u2x mod m，与 b=0 时计算出的 y 相等。同样，当 b=1 时，Prover 计算 y' 应该是 u2 mod m，与 b=1 时计算出的 y 相等。

因此，如果双方都按照协议行事，Verifier 将接受 Prover 的证明。

(b) 可靠性：
假设 QR(m,x)=0，即 x 不是模 m 下的二次剩余。在这种情况下，Prover 不知道任何有效的 s。

根据协议，Prover 随机选择一个 t ∈ Zm，并将 y 发送给 Verifier。无论 Prover 如何选择 t，由于 x 不是模 m 下的二次剩余，y 并不是通过计算 s2x mod m 得到的。

当 Verifier 收到 b 后，无论 b 的值是 0 还是 1，Verifier 根据 b 和 u 的值计算 y'。由于 Prover 没有任何有效的 s，无论 Prover 如何计算 u，y' 都不能等于正确的值。

因此，当 QR(m,x)=0 时，无论 Prover 做什么，Verifier 都以 ≥1/2 的概率拒绝。

(b*) 知识可靠性：
在协议中，如果允许 Verifier 同时查询 b∈{0,1} 两个值（对于相同的 t），则可以从 Prover 中提取秘密 s。这是因为当 b=1 时，Prover 计算的 u 是 st，其中 s 是一个秘密整数，而当 b=0 时，Prover 计算的 u 是 t。因此，通过观察 u 的变化，Verifier 可以推断出 s 的值。

由于在协议中并不要求 Prover 提供 s 或与 s 相关的信息，因此如果 Prover 不知道任何有效的 s，Verifier 将无法从 Prover 中提取秘密 s。

因此，知识可靠性得到满足。

(c) 零知识：
无论验证者做什么，验证者可以在不与证明者交互的情况下自行模拟整个交互。验证者可以自己生成一个随机的 u 而不是从 Prover 获取 u，并根据自身生成的 u 值计算 y'。因为验证者不依赖于 Prover 的输入和计算，所以验证者可以独立进行模拟而不与 Prover 进行交互。

由于验证者可以在不与证明者交互的情况下模拟整个交互，并且模拟中记录下来的信息与实际交互几乎不可区分，因此协议满足零知识性质。

综上所述，根据完备性、可靠性、知识可靠性和零知识性质的检查，我们可以得出结论：如果双方都按照协议行事，则 Verifier 总是接受；如果 QR(m,x)=0（特别是，Prover 不知道任何有效的 s），那么无论 Prover 做什么，Verifier 都以 ≥1/2 的几率拒绝；并且除非 Prover "知道" s，否则 Prover 无法说服 Verifier。同时，验证者可以在不与证明者交互的情况下自行模拟整个交互，这样如果验证者接受，那么记录下来的信息与实际交互几乎不可区分。


## 第三题

太难了
